
#ifndef _BYTECODE_H
#define _BYTECODE_H

#include "Basic.h"
#include "Parser.h"
#include "Analyzer.h"

// @NOTE: instructions are ordered in a way to be able to be generated by adding
// to the base one, ex. LOADB + 2 is LOADDW, don't reorder them in a way that messes
// this up
typedef enum : uint8_t
{
	NOP,

	LOADB,   // load byte
	LOADW,   // load word (16 bits)
	LOADDW,  // load double word (32 bits)
	LOADQW,  // load quad word (64 bits)
	LOADF,   // load float (32 bits)
	LOADD,   // load double (64 bits)
	
	STOREB,   // store byte
	STOREW,   // store word (16 bits)
	STOREDW,  // store double word (32 bits)
	STOREQW,  // store quad word (64 bits)
	STOREF,   // store float (32 bits)
	STORED,   // store double (64 bits)

	PUSHB,   // push byte on stack (as int)
	PUSHW,   // push word (16 bits) on stack (as int)
	PUSHDW,  // push double word (32 bits) on stack
	PUSHQW,  // push quad word (64 bits) on stack
	PUSHF,   // push float (32 bits) on stack
	PUSHD,   // push double (64 bits) on stack

	ADDDW,
	ADDQW,
	ADDF,
	ADDD,

	SUBDW,
	SUBQW,
	SUBF,
	SUBD,

	MULDW,
	MULQW,
	MULF,
	MULD,

	DIVDW,
	DIVQW,
	DIVF,
	DIVD,
} OP;

typedef struct
{
	u8 *bytecode;
	int i;
} Bytecode;

typedef struct
{
	char *key;
	int value;
} Alloc_Table;

Bytecode generate_bytecode(Node *tree);
void generate_expression(Node *expression, Bytecode *bytecode);

#endif // _BYTECODE_H

